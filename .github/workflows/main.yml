name: CI/CD Pipeline

on:
  push:
    branches: [master]
  pull_request:
    branches: [master]
  workflow_dispatch:

jobs:
  test-and-build:
    name: Continuous Integration
    runs-on: ubuntu-latest

    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: ${{ secrets.MYSQL_ROOT_PASSWORD }}
          MYSQL_DATABASE: ${{ secrets.MYSQL_DATABASE }}
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma Client
        run: npx prisma generate

      - name: Run TypeScript Build
        run: npm run build

      - name: Build Docker Image (Dry Run)
        run: docker build -t test-image .

  infrastructure:
    name: Infrastructure Provisioning
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/master'
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      TF_VAR_key_name: ${{ secrets.AWS_KEY_NAME }}
      TF_VAR_project_name: ${{ vars.PROJECT_NAME }}
      TF_VAR_aws_region: ${{ vars.AWS_REGION }}
      TF_VAR_instance_type: ${{ vars.INSTANCE_TYPE }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Terraform Init
        run: |
          cd terraform
          terraform init \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
            -backend-config="key=prod/terraform.tfstate" \
            -backend-config="region=${{ vars.AWS_REGION }}" \
            -backend-config="dynamodb_table=${{ secrets.TF_STATE_TABLE }}"

      - name: Terraform Plan
        run: cd terraform && terraform plan

      # Only apply if not a PR
      - name: Terraform Apply
        run: cd terraform && terraform apply -auto-approve

      - name: Wait for Cloud-Init to finish
        run: |
          echo "Waiting for EC2 to finish system updates before Ansible..."
          sleep 60

      - name: Get EC2 IP
        id: ip
        run: |
          cd terraform
          echo "EC2_IP=$(terraform output -raw instance_public_ip)" >> $GITHUB_OUTPUT

    outputs:
      ec2_ip: ${{ steps.ip.outputs.EC2_IP }}

  deploy:
    name: Continuous Deployment (EC2)
    runs-on: ubuntu-latest
    needs: [test-and-build, infrastructure]
    if: github.event_name == 'push' && github.ref == 'refs/heads/master'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Ansible collections
        run: |
          ansible-galaxy collection install -r ansible/requirements.yml

      - name: Configure EC2 with Ansible
        uses: dawidd6/action-ansible-playbook@v2
        with:
          playbook: ansible/playbook.yml
          directory: ./
          key: ${{ secrets.EC2_SSH_KEY }}
          inventory: |
            [all]
            ${{ needs.infrastructure.outputs.ec2_ip }} ansible_user=${{ secrets.EC2_USERNAME }}
          options: |
            --extra-vars "ansible_ssh_extra_args='-o StrictHostKeyChecking=no'"

      - name: Deploy to EC2 via SSH
        uses: appleboy/ssh-action@master
        with:
          host: ${{ needs.infrastructure.outputs.ec2_ip }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            APP_DIR="/home/${{ secrets.EC2_USERNAME }}/app"
            cd $APP_DIR || mkdir -p $APP_DIR && cd $APP_DIR

            # Update source code
            if [ ! -d ".git" ]; then
              git clone https://github.com/${{ github.repository }}.git .
            else
              git fetch origin master
              git reset --hard origin/master
            fi

            # Create .env file with all secrets
            {
              echo "DATABASE_URL=${{ secrets.DATABASE_URL }}"
              echo "JWT_SECRET=${{ secrets.JWT_SECRET }}"
              echo "PORT=3000"
              echo "MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}"
              echo "MYSQL_DATABASE=${{ secrets.MYSQL_DATABASE }}"
              echo "MYSQL_USER=root"
              echo "MYSQL_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}"
              echo "NODE_ENV=production"
            } > .env

            # Verify .env was created
            echo "=== .env file created successfully ==="
            cat .env
            echo "=== End of .env file ==="

            # Ensure nginx directory exists and is clean
            mkdir -p nginx && chmod 755 nginx

            # Start stack
            docker compose down --remove-orphans
            if ! docker compose up --build -d; then
              echo "Docker Compose failed to start!"
              exit 1
            fi

            # Cleanup
            docker image prune -f
      
      - name: Debug Containers on Failure
        if: failure()
        uses: appleboy/ssh-action@master
        with:
          host: ${{ needs.infrastructure.outputs.ec2_ip }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            cd /home/${{ secrets.EC2_USERNAME }}/app
            echo "--- DOCKER STATUS ---"
            docker compose ps
            echo "--- APP LOGS ---"
            docker compose logs --tail=100 app
            echo "--- DB LOGS ---"
            docker compose logs --tail=100 db
            echo "--- NGINX LOGS ---"
            docker compose logs --tail=100 nginx
            echo "--- PORT CHECK ---"
            sudo netstat -tulpn | grep :80 || echo "Port 80 is NOT listening"
            echo "--- FIREWALL STATUS ---"
            sudo ufw status
            echo "--- DOCKER NETWORK ---"
            docker network ls

      - name: Verify Deployment Health
        shell: bash
        run: |
          echo "Waiting for Docker containers to be healthy..."
          HEALTH_URL="http://${{ needs.infrastructure.outputs.ec2_ip }}/health"
          MAX_RETRIES=20
          COUNT=0
          
          until [ $COUNT -ge $MAX_RETRIES ]
          do
            echo "Checking $HEALTH_URL (Attempt $((COUNT+1))/$MAX_RETRIES)..."
            
            # Use -m 10 for 10s timeout
            HTTP_RESPONSE=$(curl -s -m 10 -v -w "HTTP_CODE:%{http_code}" $HEALTH_URL 2>&1 || true)
            HTTP_CODE=$(echo "$HTTP_RESPONSE" | grep -o 'HTTP_CODE:[0-9]*' | cut -d: -f2)
            
            echo "HTTP Code: $HTTP_CODE"
            
            if [ "$HTTP_CODE" == "200" ]; then
              echo "Deployment is healthy and live!"
              exit 0
            elif [ "$HTTP_CODE" == "502" ]; then
              echo "Nginx is online! Still waiting for App container/Database (502 Gateway)..."
            elif [ "$HTTP_CODE" == "000" ] || [ -z "$HTTP_CODE" ]; then
              echo "Server is not reachable yet (Connection Refused/Timeout)..."
            else
              echo "Received unexpected HTTP Code: $HTTP_CODE"
              # Show snippet of response body if not 000
              echo "$HTTP_RESPONSE" | tail -n 5
            fi
            
            echo "Waiting 15 seconds..."
            sleep 15
            COUNT=$((COUNT + 1))
          done
          
          echo "Health check failed after $MAX_RETRIES attempts!"
          exit 1
