name: CI/CD Pipeline

on:
  push:
    branches: [master]
  pull_request:
    branches: [master]
  workflow_dispatch:

jobs:
  test-and-build:
    name: Continuous Integration
    runs-on: ubuntu-latest

    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: ${{ secrets.MYSQL_ROOT_PASSWORD }}
          MYSQL_DATABASE: ${{ secrets.MYSQL_DATABASE }}
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma Client
        run: npx prisma generate

      - name: Run TypeScript Build
        run: npm run build

      - name: Build Docker Image (Dry Run)
        run: docker build -t test-image .

  infrastructure:
    name: Infrastructure Provisioning
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/master'
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      TF_VAR_key_name: ${{ secrets.AWS_KEY_NAME }}
      TF_VAR_project_name: ${{ vars.PROJECT_NAME }}
      TF_VAR_aws_region: ${{ vars.AWS_REGION }}
      TF_VAR_instance_type: ${{ vars.INSTANCE_TYPE }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Terraform Init
        run: |
          cd terraform
          terraform init \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
            -backend-config="key=prod/terraform.tfstate" \
            -backend-config="region=${{ vars.AWS_REGION }}" \
            -backend-config="dynamodb_table=${{ secrets.TF_STATE_TABLE }}"

      - name: Terraform Plan
        run: cd terraform && terraform plan

      # Only apply if not a PR
      - name: Terraform Apply
        run: cd terraform && terraform apply -auto-approve

      - name: Wait for Cloud-Init to finish
        run: |
          echo "Waiting for EC2 to finish system updates before Ansible..."
          sleep 60

      - name: Get EC2 IP
        id: ip
        run: |
          cd terraform
          echo "EC2_IP=$(terraform output -raw instance_public_ip)" >> $GITHUB_OUTPUT

    outputs:
      ec2_ip: ${{ steps.ip.outputs.EC2_IP }}

  deploy:
    name: Continuous Deployment (EC2)
    runs-on: ubuntu-latest
    needs: [test-and-build, infrastructure]
    if: github.event_name == 'push' && github.ref == 'refs/heads/master'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Ansible collections
        run: |
          ansible-galaxy collection install -r ansible/requirements.yml

      - name: Configure EC2 with Ansible
        uses: dawidd6/action-ansible-playbook@v2
        with:
          playbook: ansible/playbook.yml
          directory: ./
          key: ${{ secrets.EC2_SSH_KEY }}
          inventory: |
            [all]
            ${{ needs.infrastructure.outputs.ec2_ip }} ansible_user=${{ secrets.EC2_USERNAME }}
          options: |
            --extra-vars "ansible_ssh_extra_args='-o StrictHostKeyChecking=no'"

      - name: Deploy to EC2 via SSH
        uses: appleboy/ssh-action@master
        with:
          host: ${{ needs.infrastructure.outputs.ec2_ip }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            APP_DIR="/home/${{ secrets.EC2_USERNAME }}/app"
            cd $APP_DIR || mkdir -p $APP_DIR && cd $APP_DIR

            # Update source code
            if [ ! -d ".git" ]; then
              git clone https://github.com/${{ github.repository }}.git .
            else
              git fetch origin master
              git reset --hard origin/master
            fi

            # Update environment variables
            cat <<EOF > .env
            DATABASE_URL=${{ secrets.DATABASE_URL }}
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            PORT=${{ secrets.APP_PORT || 3000 }}
            MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}
            MYSQL_DATABASE=${{ secrets.MYSQL_DATABASE }}
            MYSQL_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}
            MYSQL_USER=root
            NODE_ENV=production
            EOF

            # Start stack
            docker compose up --build -d

            # Cleanup
            docker image prune -f
      
      - name: Debug Containers on Failure
        if: failure()
        uses: appleboy/ssh-action@master
        with:
          host: ${{ needs.infrastructure.outputs.ec2_ip }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            cd /home/${{ secrets.EC2_USERNAME }}/app
            echo "--- DOCKER PS ---"
            docker compose ps
            echo "--- APP LOGS ---"
            docker compose logs --tail=100 app
            echo "--- DB LOGS ---"
            docker compose logs --tail=100 db
            echo "--- NGINX LOGS ---"
            docker compose logs --tail=100 nginx

      - name: Verify Deployment Health
        run: |
          echo "Waiting for Docker containers to be healthy..."
          HEALTH_URL="http://${{ needs.infrastructure.outputs.ec2_ip }}/health"
          MAX_RETRIES=15
          COUNT=0
          
          until [ $COUNT -ge $MAX_RETRIES ]
          do
            echo "Checking $HEALTH_URL (Attempt $((COUNT+1))/$MAX_RETRIES)..."
            # Get HTTP code and response body
            HTTP_RESPONSE=$(curl -s -w "HTTP_CODE:%{http_code}" $HEALTH_URL || echo "CURL_FAILED HTTP_CODE:000")
            HTTP_CODE=$(echo "$HTTP_RESPONSE" | grep -o 'HTTP_CODE:[0-9]*' | cut -d: -f2)
            BODY=$(echo "$HTTP_RESPONSE" | sed 's/HTTP_CODE:[0-9]*//')
            
            echo "HTTP Code: $HTTP_CODE"
            echo "Response: $BODY"
            
            HEALTH_STATUS=$(echo "$BODY" | jq -r .status 2>/dev/null || echo "error")
            
            if [ "$HEALTH_STATUS" == "UP" ] && [ "$HTTP_CODE" == "200" ]; then
              echo "Deployment is healthy and live!"
              exit 0
            fi
            
            if [ "$HTTP_CODE" == "502" ]; then
              echo "Nginx is up but App is still starting (502 Bad Gateway)..."
            elif [ "$HTTP_CODE" == "000" ]; then
              echo "Server is not reachable yet (Connection Refused)..."
            fi
            
            echo "Waiting 15 seconds before next retry..."
            sleep 15
            COUNT=$((COUNT+1))
          done
          
          echo "Health check failed after $MAX_RETRIES attempts!"
          echo "Final check for logs..."
          exit 1
